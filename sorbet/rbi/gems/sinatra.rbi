# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/sinatra/all/sinatra.rbi
#
# sinatra-1.3.6

module Sinatra
  def self.helpers(*extensions, &block); end
  def self.new(base = nil, options = nil, &block); end
  def self.register(*extensions, &block); end
  def self.use(*args, &block); end
end
class Sinatra::ShowExceptions < Rack::ShowExceptions
  def call(env); end
  def frame_class(frame); end
  def initialize(app); end
end
class Sinatra::Request < Rack::Request
  def accept; end
  def accept?(*types); end
  def accept_entry(entry); end
  def forwarded?; end
  def idempotent?; end
  def preferred_type(*types); end
  def safe?; end
  def secure?; end
end
class Sinatra::Response < Rack::Response
  def body=(value); end
  def calculate_content_length?; end
  def drop_body?; end
  def drop_content_info?; end
  def each; end
  def finish; end
  def initialize(*arg0); end
end
class Anonymous_Struct_9 < Struct
  def app; end
  def app=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Sinatra::ExtendedRack < Anonymous_Struct_9
  def after_response(&block); end
  def async?(status, headers, body); end
  def call(env); end
  def setup_close(env, status, headers, body); end
end
class Sinatra::CommonLogger < Rack::CommonLogger
  def call(env); end
end
class Rack::CommonLogger
  def call_without_check(env); end
end
class Sinatra::NotFound < NameError
  def code; end
end
module Sinatra::Helpers
  def attachment(filename = nil); end
  def back; end
  def body(value = nil, &block); end
  def cache_control(*values); end
  def client_error?; end
  def content_type(type = nil, params = nil); end
  def error(code, body = nil); end
  def etag(value, options = nil); end
  def etag_matches?(list, new_resource = nil); end
  def expires(amount, *values); end
  def headers(hash = nil); end
  def informational?; end
  def last_modified(time); end
  def logger; end
  def mime_type(type); end
  def not_found(body = nil); end
  def not_found?; end
  def redirect(uri, *args); end
  def redirect?; end
  def send_file(path, opts = nil); end
  def server_error?; end
  def session; end
  def status(value = nil); end
  def stream(keep_open = nil); end
  def success?; end
  def time_for(value); end
  def to(addr = nil, absolute = nil, add_script_name = nil); end
  def uri(addr = nil, absolute = nil, add_script_name = nil); end
  def url(addr = nil, absolute = nil, add_script_name = nil); end
  def with_params(temp_params); end
end
class Sinatra::Helpers::Stream
  def <<(data); end
  def callback(&block); end
  def close; end
  def each(&front); end
  def errback(&block); end
  def initialize(scheduler = nil, keep_open = nil, &back); end
  def self.defer(*arg0); end
  def self.schedule(*arg0); end
end
module Sinatra::Templates
  def builder(template = nil, options = nil, locals = nil, &block); end
  def coffee(template, options = nil, locals = nil); end
  def compile_template(engine, data, options, views); end
  def creole(template, options = nil, locals = nil); end
  def erb(template, options = nil, locals = nil); end
  def erubis(template, options = nil, locals = nil); end
  def find_template(views, name, engine); end
  def haml(template, options = nil, locals = nil); end
  def initialize; end
  def less(template, options = nil, locals = nil); end
  def liquid(template, options = nil, locals = nil); end
  def markaby(template = nil, options = nil, locals = nil, &block); end
  def markdown(template, options = nil, locals = nil); end
  def nokogiri(template = nil, options = nil, locals = nil, &block); end
  def radius(template, options = nil, locals = nil); end
  def rdoc(template, options = nil, locals = nil); end
  def render(engine, data, options = nil, locals = nil, &block); end
  def render_ruby(engine, template, options = nil, locals = nil, &block); end
  def sass(template, options = nil, locals = nil); end
  def scss(template, options = nil, locals = nil); end
  def slim(template, options = nil, locals = nil); end
  def textile(template, options = nil, locals = nil); end
end
module Sinatra::Templates::ContentTyped
  def content_type; end
  def content_type=(arg0); end
end
class Sinatra::Base
  def app; end
  def app=(arg0); end
  def call!(env); end
  def call(env); end
  def dispatch!; end
  def dump_errors!(boom); end
  def env; end
  def env=(arg0); end
  def error_block!(key, *block_params); end
  def filter!(type, base = nil); end
  def force_encoding(*args); end
  def forward; end
  def halt(*response); end
  def handle_exception!(boom); end
  def indifferent_hash; end
  def indifferent_params(params); end
  def initialize(app = nil); end
  def invoke; end
  def options; end
  def params; end
  def params=(arg0); end
  def pass(&block); end
  def process_route(pattern, keys, conditions, block = nil, values = nil); end
  def request; end
  def request=(arg0); end
  def response; end
  def response=(arg0); end
  def route!(base = nil, pass_block = nil); end
  def route_eval; end
  def route_missing; end
  def self.absolute_redirects; end
  def self.absolute_redirects=(val); end
  def self.absolute_redirects?; end
  def self.add_charset; end
  def self.add_charset=(val); end
  def self.add_charset?; end
  def self.add_filter(type, path = nil, options = nil, &block); end
  def self.after(path = nil, options = nil, &block); end
  def self.agent(pattern); end
  def self.app_file; end
  def self.app_file=(val); end
  def self.app_file?; end
  def self.before(path = nil, options = nil, &block); end
  def self.bind; end
  def self.bind=(val); end
  def self.bind?; end
  def self.build(builder, *args, &bk); end
  def self.call(env); end
  def self.caller_files; end
  def self.caller_locations; end
  def self.cleaned_caller(keep = nil); end
  def self.compile!(verb, path, block, options = nil); end
  def self.compile(path); end
  def self.condition(name = nil, &block); end
  def self.configure(*envs, &block); end
  def self.default_encoding; end
  def self.default_encoding=(val); end
  def self.default_encoding?; end
  def self.define_singleton(name, content = nil); end
  def self.delete(path, opts = nil, &bk); end
  def self.detect_rack_handler; end
  def self.development?; end
  def self.disable(*opts); end
  def self.dump_errors; end
  def self.dump_errors=(val); end
  def self.dump_errors?; end
  def self.empty_path_info; end
  def self.empty_path_info=(val); end
  def self.empty_path_info?; end
  def self.enable(*opts); end
  def self.encoded(char); end
  def self.environment; end
  def self.environment=(val); end
  def self.environment?; end
  def self.error(*codes, &block); end
  def self.errors; end
  def self.extensions; end
  def self.filters; end
  def self.force_encoding(data, encoding = nil); end
  def self.generate_method(method_name, &block); end
  def self.get(path, opts = nil, &block); end
  def self.head(path, opts = nil, &bk); end
  def self.helpers(*extensions, &block); end
  def self.host_name(pattern); end
  def self.inherited(subclass); end
  def self.inline_templates=(file = nil); end
  def self.invoke_hook(name, *args); end
  def self.layout(name = nil, &block); end
  def self.lock; end
  def self.lock=(val); end
  def self.lock?; end
  def self.logging; end
  def self.logging=(val); end
  def self.logging?; end
  def self.method_override; end
  def self.method_override=(val); end
  def self.method_override?; end
  def self.methodoverride=(val); end
  def self.methodoverride?; end
  def self.middleware; end
  def self.mime_type(type, value = nil); end
  def self.mime_types(type); end
  def self.new!(*arg0); end
  def self.new(*args, &bk); end
  def self.not_found(&block); end
  def self.options(path, opts = nil, &bk); end
  def self.patch(path, opts = nil, &bk); end
  def self.port; end
  def self.port=(val); end
  def self.port?; end
  def self.post(path, opts = nil, &bk); end
  def self.prefixed_redirects; end
  def self.prefixed_redirects=(val); end
  def self.prefixed_redirects?; end
  def self.production?; end
  def self.protection; end
  def self.protection=(val); end
  def self.protection?; end
  def self.prototype; end
  def self.provides(*types); end
  def self.public=(value); end
  def self.public_folder; end
  def self.public_folder=(val); end
  def self.public_folder?; end
  def self.put(path, opts = nil, &bk); end
  def self.quit!(server, handler_name); end
  def self.raise_errors; end
  def self.raise_errors=(val); end
  def self.raise_errors?; end
  def self.register(*extensions, &block); end
  def self.reload_templates; end
  def self.reload_templates=(val); end
  def self.reload_templates?; end
  def self.reset!; end
  def self.root; end
  def self.root=(val); end
  def self.root?; end
  def self.route(verb, path, options = nil, &block); end
  def self.routes; end
  def self.run!(options = nil); end
  def self.run; end
  def self.run=(val); end
  def self.run?; end
  def self.running; end
  def self.running=(val); end
  def self.running?; end
  def self.server; end
  def self.server=(val); end
  def self.server?; end
  def self.session_secret; end
  def self.session_secret=(val); end
  def self.session_secret?; end
  def self.sessions; end
  def self.sessions=(val); end
  def self.sessions?; end
  def self.set(option, value = nil, ignore_setter = nil, &block); end
  def self.settings; end
  def self.setup_common_logger(builder); end
  def self.setup_custom_logger(builder); end
  def self.setup_default_middleware(builder); end
  def self.setup_logging(builder); end
  def self.setup_middleware(builder); end
  def self.setup_null_logger(builder); end
  def self.setup_protection(builder); end
  def self.setup_sessions(builder); end
  def self.show_exceptions; end
  def self.show_exceptions=(val); end
  def self.show_exceptions?; end
  def self.static; end
  def self.static=(val); end
  def self.static?; end
  def self.static_cache_control; end
  def self.static_cache_control=(val); end
  def self.static_cache_control?; end
  def self.synchronize(&block); end
  def self.template(name, &block); end
  def self.templates; end
  def self.test?; end
  def self.threaded; end
  def self.threaded=(val); end
  def self.threaded?; end
  def self.use(middleware, *args, &block); end
  def self.user_agent(pattern); end
  def self.views; end
  def self.views=(val); end
  def self.views?; end
  def self.warn(message); end
  def settings; end
  def static!; end
  def template_cache; end
  include Rack::Utils
  include Sinatra::Helpers
  include Sinatra::Templates
end
class Sinatra::Application < Sinatra::Base
  def self.app_file; end
  def self.app_file=(val); end
  def self.app_file?; end
  def self.logging; end
  def self.logging=(val); end
  def self.logging?; end
  def self.method_override; end
  def self.method_override=(val); end
  def self.method_override?; end
  def self.register(*extensions, &block); end
  def self.run; end
  def self.run=(val); end
  def self.run?; end
  def self.session_secret; end
  def self.session_secret=(val); end
  def self.session_secret?; end
end
module Sinatra::Delegator
  def after(*args, &block); end
  def before(*args, &block); end
  def configure(*args, &block); end
  def delete(*args, &block); end
  def development?(*args, &block); end
  def disable(*args, &block); end
  def enable(*args, &block); end
  def error(*args, &block); end
  def get(*args, &block); end
  def head(*args, &block); end
  def helpers(*args, &block); end
  def layout(*args, &block); end
  def mime_type(*args, &block); end
  def not_found(*args, &block); end
  def options(*args, &block); end
  def patch(*args, &block); end
  def post(*args, &block); end
  def production?(*args, &block); end
  def put(*args, &block); end
  def self.delegate(*methods); end
  def self.target; end
  def self.target=(arg0); end
  def set(*args, &block); end
  def settings(*args, &block); end
  def template(*args, &block); end
  def test?(*args, &block); end
  def use(*args, &block); end
end
