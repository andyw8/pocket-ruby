# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `regexp_parser` gem.
# Please instead update this file by running `bin/tapioca gem regexp_parser`.

module Regexp::Expression; end

class Regexp::Expression::Alternation < ::Regexp::Expression::SequenceOperation
  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#5
  def alternatives; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#127
  def match_length; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/alternation.rb#6
Regexp::Expression::Alternation::OPERAND = Regexp::Expression::Alternative

# A sequence of expressions, used by Alternation as one of its alternative.
class Regexp::Expression::Alternative < ::Regexp::Expression::Sequence; end

module Regexp::Expression::Anchor; end

# source://regexp_parser//lib/regexp_parser/expression/classes/anchor.rb#18
Regexp::Expression::Anchor::BOL = Regexp::Expression::Anchor::BeginningOfLine

# source://regexp_parser//lib/regexp_parser/expression/classes/anchor.rb#20
Regexp::Expression::Anchor::BOS = Regexp::Expression::Anchor::BeginningOfString

class Regexp::Expression::Anchor::Base < ::Regexp::Expression::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#144
  def match_length; end
end

class Regexp::Expression::Anchor::BeginningOfLine < ::Regexp::Expression::Anchor::Base; end
class Regexp::Expression::Anchor::BeginningOfString < ::Regexp::Expression::Anchor::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/anchor.rb#19
Regexp::Expression::Anchor::EOL = Regexp::Expression::Anchor::EndOfLine

# source://regexp_parser//lib/regexp_parser/expression/classes/anchor.rb#21
Regexp::Expression::Anchor::EOS = Regexp::Expression::Anchor::EndOfString

# source://regexp_parser//lib/regexp_parser/expression/classes/anchor.rb#22
Regexp::Expression::Anchor::EOSobEOL = Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine

class Regexp::Expression::Anchor::EndOfLine < ::Regexp::Expression::Anchor::Base; end
class Regexp::Expression::Anchor::EndOfString < ::Regexp::Expression::Anchor::Base; end
class Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine < ::Regexp::Expression::Anchor::Base; end
class Regexp::Expression::Anchor::MatchStart < ::Regexp::Expression::Anchor::Base; end
class Regexp::Expression::Anchor::NonWordBoundary < ::Regexp::Expression::Anchor::Base; end
class Regexp::Expression::Anchor::WordBoundary < ::Regexp::Expression::Anchor::Base; end
module Regexp::Expression::Assertion; end

class Regexp::Expression::Assertion::Base < ::Regexp::Expression::Group::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#144
  def match_length; end
end

class Regexp::Expression::Assertion::Lookahead < ::Regexp::Expression::Assertion::Base; end
class Regexp::Expression::Assertion::Lookbehind < ::Regexp::Expression::Assertion::Base; end
class Regexp::Expression::Assertion::NegativeLookahead < ::Regexp::Expression::Assertion::Base; end
class Regexp::Expression::Assertion::NegativeLookbehind < ::Regexp::Expression::Assertion::Base; end
module Regexp::Expression::Backreference; end

class Regexp::Expression::Backreference::Base < ::Regexp::Expression::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#151
  def match_length; end

  # Returns the value of attribute referenced_expression.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#4
  def referenced_expression; end

  # Sets the attribute referenced_expression
  #
  # @param value the value to set the attribute referenced_expression to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#4
  def referenced_expression=(_arg0); end

  private

  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#6
  def initialize_copy(orig); end
end

class Regexp::Expression::Backreference::Name < ::Regexp::Expression::Backreference::Base
  # @return [Name] a new instance of Name
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#26
  def initialize(token, options = T.unsafe(nil)); end

  # Returns the value of attribute name.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#23
  def name; end

  # Returns the value of attribute name.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#23
  def reference; end
end

class Regexp::Expression::Backreference::NameCall < ::Regexp::Expression::Backreference::Name; end

class Regexp::Expression::Backreference::NameRecursionLevel < ::Regexp::Expression::Backreference::Name
  # @return [NameRecursionLevel] a new instance of NameRecursionLevel
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#53
  def initialize(token, options = T.unsafe(nil)); end

  # Returns the value of attribute recursion_level.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#51
  def recursion_level; end
end

class Regexp::Expression::Backreference::Number < ::Regexp::Expression::Backreference::Base
  # @return [Number] a new instance of Number
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#16
  def initialize(token, options = T.unsafe(nil)); end

  # Returns the value of attribute number.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#13
  def number; end

  # Returns the value of attribute number.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#13
  def reference; end
end

class Regexp::Expression::Backreference::NumberCall < ::Regexp::Expression::Backreference::Number; end
class Regexp::Expression::Backreference::NumberCallRelative < ::Regexp::Expression::Backreference::NumberRelative; end

class Regexp::Expression::Backreference::NumberRecursionLevel < ::Regexp::Expression::Backreference::Number
  # @return [NumberRecursionLevel] a new instance of NumberRecursionLevel
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#44
  def initialize(token, options = T.unsafe(nil)); end

  # Returns the value of attribute recursion_level.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#42
  def recursion_level; end
end

class Regexp::Expression::Backreference::NumberRelative < ::Regexp::Expression::Backreference::Number
  # Returns the value of attribute effective_number.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#33
  def effective_number; end

  # Sets the attribute effective_number
  #
  # @param value the value to set the attribute effective_number to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#33
  def effective_number=(_arg0); end

  # Returns the value of attribute effective_number.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#33
  def reference; end
end

class Regexp::Expression::Base
  include ::RuboCop::Ext::RegexpParser::Expression::Base

  # @return [Base] a new instance of Base
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#10
  def initialize(token, options = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match.rb#8
  def =~(string, offset = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#25
  def a?; end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#25
  def ascii_classes?; end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#107
  def attributes; end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#36
  def base_length; end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#8
  def case_insensitive?; end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#48
  def coded_offset; end

  # Returns the value of attribute conditional_level.
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#5
  def conditional_level; end

  # Sets the attribute conditional_level
  #
  # @param value the value to set the attribute conditional_level to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#5
  def conditional_level=(_arg0); end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#20
  def d?; end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#20
  def default_classes?; end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#14
  def extended?; end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#14
  def free_spacing?; end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#40
  def full_length; end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#94
  def greedy?; end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#8
  def i?; end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#8
  def ignore_case?; end

  # Test if this expression has the given test_token, and optionally a given
  # test_type.
  #
  #   # Any expressions
  #   exp.is? :*  # always returns true
  #
  #   # is it a :capture
  #   exp.is? :capture
  #
  #   # is it a :character and a :set
  #   exp.is? :character, :set
  #
  #   # is it a :meta :dot
  #   exp.is? :dot, :meta
  #
  #   # is it a :meta or :escape :dot
  #   exp.is? :dot, [:meta, :escape]
  #
  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#36
  def is?(test_token, test_type = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#98
  def lazy?; end

  # Returns the value of attribute level.
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#5
  def level; end

  # Sets the attribute level
  #
  # @param value the value to set the attribute level to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#5
  def level=(_arg0); end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#3
  def m?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match.rb#8
  def match(string, offset = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/match.rb#3
  def match?(string); end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/match.rb#3
  def matches?(string); end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#3
  def multiline?; end

  # Returns the value of attribute nesting_level.
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#5
  def nesting_level; end

  # Sets the attribute nesting_level
  #
  # @param value the value to set the attribute nesting_level to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#5
  def nesting_level=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#44
  def offset; end

  # Test if this expression matches an entry in the given scope spec.
  #
  # A scope spec can be one of:
  #
  #   . An array: Interpreted as a set of tokens, tested for inclusion
  #               of the expression's token.
  #
  #   . A hash:   Where the key is interpreted as the expression type
  #               and the value is either a symbol or an array. In this
  #               case, when the scope is a hash, one_of? calls itself to
  #               evaluate the key's value.
  #
  #   . A symbol: matches the expression's token or type, depending on
  #               the level of the call. If one_of? is called directly with
  #               a symbol then it will always be checked against the
  #               type of the expression. If it's being called for a value
  #               from a hash, it will be checked against the token of the
  #               expression.
  #
  #   # any expression
  #   exp.one_of?(:*) # always true
  #
  #   # like exp.type?(:group)
  #   exp.one_of?(:group)
  #
  #   # any expression of type meta
  #   exp.one_of?(:meta => :*)
  #
  #   # meta dots and alternations
  #   exp.one_of?(:meta => [:dot, :alternation])
  #
  #   # meta dots and any set tokens
  #   exp.one_of?({meta: [:dot], set: :*})
  #
  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#75
  def one_of?(scope, top = T.unsafe(nil)); end

  # Returns the value of attribute options.
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#8
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#8
  def options=(_arg0); end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#103
  def possessive?; end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#72
  def quantified?; end

  # Returns the value of attribute quantifier.
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#7
  def quantifier; end

  # Sets the attribute quantifier
  #
  # @param value the value to set the attribute quantifier to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#7
  def quantifier=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#56
  def quantifier_affix(expression_format); end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#64
  def quantify(token, text, min = T.unsafe(nil), max = T.unsafe(nil), mode = T.unsafe(nil)); end

  # Deprecated. Prefer `#repetitions` which has a more uniform interface.
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#77
  def quantity; end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#98
  def reluctant?; end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#82
  def repetitions; end

  # Returns the value of attribute set_level.
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#5
  def set_level; end

  # Sets the attribute set_level
  #
  # @param value the value to set the attribute set_level to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#5
  def set_level=(_arg0); end

  # Returns the value of attribute ts.
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#4
  def starts_at; end

  # %l  Level (depth) of the expression. Returns 'root' for the root
  #       expression, returns zero or higher for all others.
  #
  #   %>  Indentation at expression's level.
  #
  #   %x  Index of the expression at its depth. Available when using
  #       the sprintf_tree method only.
  #
  #   %s  Start offset within the whole expression.
  #   %e  End offset within the whole expression.
  #   %S  Length of expression.
  #
  #   %o  Coded offset and length, same as '@%s+%S'
  #
  #   %y  Type of expression.
  #   %k  Token of expression.
  #   %i  ID, same as '%y:%k'
  #   %c  Class name
  #
  #   %q  Quantifier info, as {m[,M]}
  #   %Q  Quantifier text
  #
  #   %z  Quantifier min
  #   %Z  Quantifier max
  #
  #   %t  Base text of the expression (excludes quantifier, if any)
  #   %~t Full text if the expression is terminal, otherwise %i
  #   %T  Full text of the expression (includes quantifier, if any)
  #
  #   %b  Basic info, same as '%o %i'
  #   %m  Most info, same as '%b %q'
  #   %a  All info, same as '%m %t'
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/strfregexp.rb#37
  def strfre(format = T.unsafe(nil), indent_offset = T.unsafe(nil), index = T.unsafe(nil)); end

  # %l  Level (depth) of the expression. Returns 'root' for the root
  #       expression, returns zero or higher for all others.
  #
  #   %>  Indentation at expression's level.
  #
  #   %x  Index of the expression at its depth. Available when using
  #       the sprintf_tree method only.
  #
  #   %s  Start offset within the whole expression.
  #   %e  End offset within the whole expression.
  #   %S  Length of expression.
  #
  #   %o  Coded offset and length, same as '@%s+%S'
  #
  #   %y  Type of expression.
  #   %k  Token of expression.
  #   %i  ID, same as '%y:%k'
  #   %c  Class name
  #
  #   %q  Quantifier info, as {m[,M]}
  #   %Q  Quantifier text
  #
  #   %z  Quantifier min
  #   %Z  Quantifier max
  #
  #   %t  Base text of the expression (excludes quantifier, if any)
  #   %~t Full text if the expression is terminal, otherwise %i
  #   %T  Full text of the expression (includes quantifier, if any)
  #
  #   %b  Basic info, same as '%o %i'
  #   %m  Most info, same as '%b %q'
  #   %a  All info, same as '%m %t'
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/strfregexp.rb#37
  def strfregexp(format = T.unsafe(nil), indent_offset = T.unsafe(nil), index = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#60
  def terminal?; end

  # Returns the value of attribute text.
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#4
  def text; end

  # Sets the attribute text
  #
  # @param value the value to set the attribute text to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#4
  def text=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#107
  def to_h; end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#30
  def to_re(format = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#52
  def to_s(format = T.unsafe(nil)); end

  # Returns the value of attribute token.
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#3
  def token; end

  # Sets the attribute token
  #
  # @param value the value to set the attribute token to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#3
  def token=(_arg0); end

  # Returns the value of attribute ts.
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#4
  def ts; end

  # Sets the attribute ts
  #
  # @param value the value to set the attribute ts to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#4
  def ts=(_arg0); end

  # Returns the value of attribute type.
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#3
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/base.rb#3
  def type=(_arg0); end

  # Test if this expression has the given test_type, which can be either
  # a symbol or an array of symbols to check against the expression's type.
  #
  #   # is it a :group expression
  #   exp.type? :group
  #
  #   # is it a :set, or :meta
  #   exp.type? [:set, :meta]
  #
  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#13
  def type?(test_type); end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#30
  def u?; end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#30
  def unicode_classes?; end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#68
  def unquantified_clone; end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#14
  def x?; end

  private

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#23
  def initialize_copy(orig); end
end

class Regexp::Expression::CharacterSet < ::Regexp::Expression::Subexpression
  include ::RuboCop::Ext::RegexpParser::Expression::CharacterSet

  # @return [CharacterSet] a new instance of CharacterSet
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set.rb#9
  def initialize(token, options = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set.rb#19
  def close; end

  # Returns the value of attribute closed.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set.rb#3
  def closed; end

  # Sets the attribute closed
  #
  # @param value the value to set the attribute closed to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set.rb#3
  def closed=(_arg0); end

  # Returns the value of attribute closed.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set.rb#3
  def closed?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#94
  def match_length; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set.rb#15
  def negate; end

  # Returns the value of attribute negative.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set.rb#3
  def negated?; end

  # Returns the value of attribute negative.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set.rb#3
  def negative; end

  # Sets the attribute negative
  #
  # @param value the value to set the attribute negative to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set.rb#3
  def negative=(_arg0); end

  # Returns the value of attribute negative.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set.rb#3
  def negative?; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set.rb#23
  def to_s(format = T.unsafe(nil)); end
end

class Regexp::Expression::CharacterSet::IntersectedSequence < ::Regexp::Expression::Sequence
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#94
  def match_length; end
end

class Regexp::Expression::CharacterSet::Intersection < ::Regexp::Expression::SequenceOperation
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#94
  def match_length; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/character_set/intersection.rb#6
Regexp::Expression::CharacterSet::Intersection::OPERAND = Regexp::Expression::CharacterSet::IntersectedSequence

class Regexp::Expression::CharacterSet::Range < ::Regexp::Expression::Subexpression
  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set/range.rb#9
  def <<(exp); end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set/range.rb#15
  def complete?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#94
  def match_length; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set/range.rb#4
  def starts_at; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set/range.rb#19
  def to_s(_format = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set/range.rb#4
  def ts; end
end

module Regexp::Expression::CharacterType; end
class Regexp::Expression::CharacterType::Any < ::Regexp::Expression::CharacterType::Base; end

class Regexp::Expression::CharacterType::Base < ::Regexp::Expression::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#94
  def match_length; end
end

class Regexp::Expression::CharacterType::Digit < ::Regexp::Expression::CharacterType::Base; end
class Regexp::Expression::CharacterType::ExtendedGrapheme < ::Regexp::Expression::CharacterType::Base; end
class Regexp::Expression::CharacterType::Hex < ::Regexp::Expression::CharacterType::Base; end
class Regexp::Expression::CharacterType::Linebreak < ::Regexp::Expression::CharacterType::Base; end
class Regexp::Expression::CharacterType::NonDigit < ::Regexp::Expression::CharacterType::Base; end
class Regexp::Expression::CharacterType::NonHex < ::Regexp::Expression::CharacterType::Base; end
class Regexp::Expression::CharacterType::NonSpace < ::Regexp::Expression::CharacterType::Base; end
class Regexp::Expression::CharacterType::NonWord < ::Regexp::Expression::CharacterType::Base; end
class Regexp::Expression::CharacterType::Space < ::Regexp::Expression::CharacterType::Base; end
class Regexp::Expression::CharacterType::Word < ::Regexp::Expression::CharacterType::Base; end
class Regexp::Expression::Comment < ::Regexp::Expression::FreeSpace; end
module Regexp::Expression::Conditional; end
class Regexp::Expression::Conditional::Branch < ::Regexp::Expression::Sequence; end

class Regexp::Expression::Conditional::Condition < ::Regexp::Expression::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#144
  def match_length; end

  # Name or number of the referenced capturing group that determines state.
  # Returns a String if reference is by name, Integer if by number.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#14
  def reference; end

  # Returns the value of attribute referenced_expression.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#10
  def referenced_expression; end

  # Sets the attribute referenced_expression
  #
  # @param value the value to set the attribute referenced_expression to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#10
  def referenced_expression=(_arg0); end

  private

  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#19
  def initialize_copy(orig); end
end

class Regexp::Expression::Conditional::Expression < ::Regexp::Expression::Subexpression
  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#30
  def <<(exp); end

  # @raise [TooManyBranches]
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#34
  def add_sequence(active_opts = T.unsafe(nil)); end

  # @raise [TooManyBranches]
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#34
  def branch(active_opts = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#50
  def branches; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#46
  def condition; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#41
  def condition=(exp); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#127
  def match_length; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#54
  def reference; end

  # Returns the value of attribute referenced_expression.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#28
  def referenced_expression; end

  # Sets the attribute referenced_expression
  #
  # @param value the value to set the attribute referenced_expression to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#28
  def referenced_expression=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#58
  def to_s(format = T.unsafe(nil)); end

  private

  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#62
  def initialize_copy(orig); end
end

class Regexp::Expression::Conditional::TooManyBranches < ::Regexp::Parser::Error
  # @return [TooManyBranches] a new instance of TooManyBranches
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#4
  def initialize; end
end

# TODO: unify naming with Token::Escape, on way or the other, in v3.0.0
module Regexp::Expression::EscapeSequence; end

class Regexp::Expression::EscapeSequence::AbstractMetaControlSequence < ::Regexp::Expression::EscapeSequence::Base
  # source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#65
  def char; end

  private

  # source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#71
  def control_sequence_to_s(control_sequence); end

  # source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#76
  def meta_char_to_codepoint(meta_char); end
end

class Regexp::Expression::EscapeSequence::AsciiEscape < ::Regexp::Expression::EscapeSequence::Base; end
class Regexp::Expression::EscapeSequence::Backspace < ::Regexp::Expression::EscapeSequence::Base; end

class Regexp::Expression::EscapeSequence::Base < ::Regexp::Expression::Base
  # source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#10
  def char; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#5
  def codepoint; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#94
  def match_length; end
end

class Regexp::Expression::EscapeSequence::Bell < ::Regexp::Expression::EscapeSequence::Base; end
class Regexp::Expression::EscapeSequence::Codepoint < ::Regexp::Expression::EscapeSequence::Base; end

class Regexp::Expression::EscapeSequence::CodepointList < ::Regexp::Expression::EscapeSequence::Base
  # @raise [NoMethodError]
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#41
  def char; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#49
  def chars; end

  # @raise [NoMethodError]
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#45
  def codepoint; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#53
  def codepoints; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#160
  def match_length; end
end

class Regexp::Expression::EscapeSequence::Control < ::Regexp::Expression::EscapeSequence::AbstractMetaControlSequence
  # source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#83
  def codepoint; end
end

class Regexp::Expression::EscapeSequence::FormFeed < ::Regexp::Expression::EscapeSequence::Base; end
class Regexp::Expression::EscapeSequence::Hex < ::Regexp::Expression::EscapeSequence::Base; end

class Regexp::Expression::EscapeSequence::Literal < ::Regexp::Expression::EscapeSequence::Base
  # source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#23
  def char; end
end

class Regexp::Expression::EscapeSequence::Meta < ::Regexp::Expression::EscapeSequence::AbstractMetaControlSequence
  # source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#89
  def codepoint; end
end

class Regexp::Expression::EscapeSequence::MetaControl < ::Regexp::Expression::EscapeSequence::AbstractMetaControlSequence
  # source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#95
  def codepoint; end
end

class Regexp::Expression::EscapeSequence::Newline < ::Regexp::Expression::EscapeSequence::Base; end

class Regexp::Expression::EscapeSequence::Octal < ::Regexp::Expression::EscapeSequence::Base
  # source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#59
  def char; end
end

class Regexp::Expression::EscapeSequence::Return < ::Regexp::Expression::EscapeSequence::Base; end
class Regexp::Expression::EscapeSequence::Tab < ::Regexp::Expression::EscapeSequence::Base; end
class Regexp::Expression::EscapeSequence::VerticalTab < ::Regexp::Expression::EscapeSequence::Base; end

class Regexp::Expression::FreeSpace < ::Regexp::Expression::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#144
  def match_length; end

  # @raise [Regexp::Parser::Error]
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/free_space.rb#3
  def quantify(_token, _text, _min = T.unsafe(nil), _max = T.unsafe(nil), _mode = T.unsafe(nil)); end
end

module Regexp::Expression::Group; end

# Special case. Absence group can match 0.. chars, irrespective of content.
# TODO: in theory, they *can* exclude match lengths with `.`: `(?~.{3})`
class Regexp::Expression::Group::Absence < ::Regexp::Expression::Group::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#168
  def match_length; end
end

class Regexp::Expression::Group::Atomic < ::Regexp::Expression::Group::Base; end

class Regexp::Expression::Group::Base < ::Regexp::Expression::Subexpression
  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#8
  def capturing?; end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#10
  def comment?; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#4
  def to_s(format = T.unsafe(nil)); end
end

class Regexp::Expression::Group::Capture < ::Regexp::Expression::Group::Base
  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#49
  def capturing?; end

  # Returns the value of attribute number.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#46
  def identifier; end

  # Returns the value of attribute number.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#46
  def number; end

  # Sets the attribute number
  #
  # @param value the value to set the attribute number to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#46
  def number=(_arg0); end

  # Returns the value of attribute number_at_level.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#46
  def number_at_level; end

  # Sets the attribute number_at_level
  #
  # @param value the value to set the attribute number_at_level to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#46
  def number_at_level=(_arg0); end
end

class Regexp::Expression::Group::Comment < ::Regexp::Expression::Group::Base
  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#72
  def comment?; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#68
  def to_s(_format = T.unsafe(nil)); end
end

class Regexp::Expression::Group::Named < ::Regexp::Expression::Group::Capture
  # @return [Named] a new instance of Named
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#56
  def initialize(token, options = T.unsafe(nil)); end

  # Returns the value of attribute name.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#53
  def identifier; end

  # Returns the value of attribute name.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#53
  def name; end

  private

  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#61
  def initialize_copy(orig); end
end

class Regexp::Expression::Group::Options < ::Regexp::Expression::Group::Base
  # Returns the value of attribute option_changes.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#37
  def option_changes; end

  # Sets the attribute option_changes
  #
  # @param value the value to set the attribute option_changes to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#37
  def option_changes=(_arg0); end

  private

  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#39
  def initialize_copy(orig); end
end

class Regexp::Expression::Group::Passive < ::Regexp::Expression::Group::Base
  # @return [Passive] a new instance of Passive
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#16
  def initialize(*_arg0); end

  # Sets the attribute implicit
  #
  # @param value the value to set the attribute implicit to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#14
  def implicit=(_arg0); end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#29
  def implicit?; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#21
  def to_s(format = T.unsafe(nil)); end
end

module Regexp::Expression::Keep; end

class Regexp::Expression::Keep::Mark < ::Regexp::Expression::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#144
  def match_length; end
end

class Regexp::Expression::Literal < ::Regexp::Expression::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#101
  def match_length; end
end

# source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#81
Regexp::Expression::MatchLength = Regexp::MatchLength

class Regexp::Expression::PosixClass < ::Regexp::Expression::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#94
  def match_length; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/posix_class.rb#7
  def name; end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/posix_class.rb#3
  def negative?; end
end

class Regexp::Expression::Quantifier
  # @return [Quantifier] a new instance of Quantifier
  #
  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#7
  def initialize(token, text, min, max, mode); end

  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#44
  def ==(other); end

  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#44
  def eq(other); end

  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#37
  def greedy?; end

  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#37
  def lazy?; end

  # Returns the value of attribute max.
  #
  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#5
  def max; end

  # Returns the value of attribute min.
  #
  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#5
  def min; end

  # Returns the value of attribute mode.
  #
  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#5
  def mode; end

  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#37
  def possessive?; end

  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#37
  def reluctant?; end

  # Returns the value of attribute text.
  #
  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#5
  def text; end

  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#25
  def to_h; end

  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#20
  def to_s; end

  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#20
  def to_str; end

  # Returns the value of attribute token.
  #
  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#5
  def token; end

  private

  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#15
  def initialize_copy(orig); end
end

# source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#3
Regexp::Expression::Quantifier::MODES = T.let(T.unsafe(nil), Array)

class Regexp::Expression::Root < ::Regexp::Expression::Subexpression
  class << self
    # source://regexp_parser//lib/regexp_parser/expression/classes/root.rb#3
    def build(options = T.unsafe(nil)); end

    # source://regexp_parser//lib/regexp_parser/expression/classes/root.rb#7
    def build_token; end
  end
end

# A sequence of expressions. Differs from a Subexpressions by how it handles
# quantifiers, as it applies them to its last element instead of itself as
# a whole subexpression.
#
# Used as the base class for the Alternation alternatives, Conditional
# branches, and CharacterSet::Intersection intersected sequences.
class Regexp::Expression::Sequence < ::Regexp::Expression::Subexpression
  # source://regexp_parser//lib/regexp_parser/expression/sequence.rb#42
  def quantify(token, text, min = T.unsafe(nil), max = T.unsafe(nil), mode = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/sequence.rb#37
  def starts_at; end

  # source://regexp_parser//lib/regexp_parser/expression/sequence.rb#37
  def ts; end

  class << self
    # source://regexp_parser//lib/regexp_parser/expression/sequence.rb#10
    def add_to(subexpression, params = T.unsafe(nil), active_opts = T.unsafe(nil)); end

    # source://regexp_parser//lib/regexp_parser/expression/sequence.rb#22
    def at_levels(level, set_level, conditional_level); end
  end
end

# abstract class
class Regexp::Expression::SequenceOperation < ::Regexp::Expression::Subexpression
  # source://regexp_parser//lib/regexp_parser/expression/sequence_operation.rb#13
  def <<(exp); end

  # source://regexp_parser//lib/regexp_parser/expression/sequence_operation.rb#17
  def add_sequence(active_opts = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#5
  def operands; end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#4
  def operator; end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#5
  def sequences; end

  # source://regexp_parser//lib/regexp_parser/expression/sequence_operation.rb#8
  def starts_at; end

  # source://regexp_parser//lib/regexp_parser/expression/sequence_operation.rb#21
  def to_s(format = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/sequence_operation.rb#8
  def ts; end
end

class Regexp::Expression::Subexpression < ::Regexp::Expression::Base
  include ::Enumerable

  # @return [Subexpression] a new instance of Subexpression
  #
  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#7
  def initialize(token, options = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#19
  def <<(exp); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#30
  def [](*args, &block); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#30
  def at(*args, &block); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#36
  def dig(*indices); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#30
  def each(*args, &block); end

  # Iterates over the expressions of this expression as an array, passing
  # the expression and its index within its parent to the given block.
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/traverse.rb#39
  def each_expression(include_self = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#30
  def empty?(*args, &block); end

  # Returns the value of attribute expressions.
  #
  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#5
  def expressions; end

  # Sets the attribute expressions
  #
  # @param value the value to set the attribute expressions to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#5
  def expressions=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#30
  def fetch(*args, &block); end

  # Returns a new array with the results of calling the given block once
  # for every expression. If a block is not given, returns an array with
  # each expression and its level index as an array.
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/traverse.rb#50
  def flat_map(include_self = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#30
  def index(*args, &block); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#114
  def inner_match_length; end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#30
  def join(*args, &block); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#30
  def last(*args, &block); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#30
  def length(*args, &block); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#107
  def match_length; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/strfregexp.rb#102
  def strfre_tree(format = T.unsafe(nil), include_self = T.unsafe(nil), separator = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/strfregexp.rb#102
  def strfregexp_tree(format = T.unsafe(nil), include_self = T.unsafe(nil), separator = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#42
  def te; end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#51
  def to_h; end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#46
  def to_s(format = T.unsafe(nil)); end

  # Traverses the subexpression (depth-first, pre-order) and calls the given
  # block for each expression with three arguments; the traversal event,
  # the expression, and the index of the expression within its parent.
  #
  # The event argument is passed as follows:
  #
  # - For subexpressions, :enter upon entering the subexpression, and
  #   :exit upon exiting it.
  #
  # - For terminal expressions, :visit is called once.
  #
  # Returns self.
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/traverse.rb#16
  def traverse(include_self = T.unsafe(nil), &block); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#30
  def values_at(*args, &block); end

  # Traverses the subexpression (depth-first, pre-order) and calls the given
  # block for each expression with three arguments; the traversal event,
  # the expression, and the index of the expression within its parent.
  #
  # The event argument is passed as follows:
  #
  # - For subexpressions, :enter upon entering the subexpression, and
  #   :exit upon exiting it.
  #
  # - For terminal expressions, :visit is called once.
  #
  # Returns self.
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/traverse.rb#16
  def walk(include_self = T.unsafe(nil), &block); end

  private

  # Override base method to clone the expressions as well.
  #
  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#14
  def initialize_copy(orig); end
end

module Regexp::Expression::UnicodeProperty; end
class Regexp::Expression::UnicodeProperty::Age < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Alnum < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Alpha < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Any < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Ascii < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Assigned < ::Regexp::Expression::UnicodeProperty::Base; end

class Regexp::Expression::UnicodeProperty::Base < ::Regexp::Expression::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#94
  def match_length; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/property.rb#8
  def name; end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/classes/property.rb#4
  def negative?; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/property.rb#12
  def shortcut; end
end

class Regexp::Expression::UnicodeProperty::Blank < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Block < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Cntrl < ::Regexp::Expression::UnicodeProperty::Base; end
module Regexp::Expression::UnicodeProperty::Codepoint; end
class Regexp::Expression::UnicodeProperty::Codepoint::Any < ::Regexp::Expression::UnicodeProperty::Codepoint::Base; end
class Regexp::Expression::UnicodeProperty::Codepoint::Base < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Codepoint::Control < ::Regexp::Expression::UnicodeProperty::Codepoint::Base; end
class Regexp::Expression::UnicodeProperty::Codepoint::Format < ::Regexp::Expression::UnicodeProperty::Codepoint::Base; end
class Regexp::Expression::UnicodeProperty::Codepoint::PrivateUse < ::Regexp::Expression::UnicodeProperty::Codepoint::Base; end
class Regexp::Expression::UnicodeProperty::Codepoint::Surrogate < ::Regexp::Expression::UnicodeProperty::Codepoint::Base; end
class Regexp::Expression::UnicodeProperty::Codepoint::Unassigned < ::Regexp::Expression::UnicodeProperty::Codepoint::Base; end
class Regexp::Expression::UnicodeProperty::Derived < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Digit < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Emoji < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Graph < ::Regexp::Expression::UnicodeProperty::Base; end
module Regexp::Expression::UnicodeProperty::Letter; end
class Regexp::Expression::UnicodeProperty::Letter::Any < ::Regexp::Expression::UnicodeProperty::Letter::Base; end
class Regexp::Expression::UnicodeProperty::Letter::Base < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Letter::Cased < ::Regexp::Expression::UnicodeProperty::Letter::Base; end
class Regexp::Expression::UnicodeProperty::Letter::Lowercase < ::Regexp::Expression::UnicodeProperty::Letter::Base; end
class Regexp::Expression::UnicodeProperty::Letter::Modifier < ::Regexp::Expression::UnicodeProperty::Letter::Base; end
class Regexp::Expression::UnicodeProperty::Letter::Other < ::Regexp::Expression::UnicodeProperty::Letter::Base; end
class Regexp::Expression::UnicodeProperty::Letter::Titlecase < ::Regexp::Expression::UnicodeProperty::Letter::Base; end
class Regexp::Expression::UnicodeProperty::Letter::Uppercase < ::Regexp::Expression::UnicodeProperty::Letter::Base; end
class Regexp::Expression::UnicodeProperty::Lower < ::Regexp::Expression::UnicodeProperty::Base; end
module Regexp::Expression::UnicodeProperty::Mark; end
class Regexp::Expression::UnicodeProperty::Mark::Any < ::Regexp::Expression::UnicodeProperty::Mark::Base; end
class Regexp::Expression::UnicodeProperty::Mark::Base < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Mark::Combining < ::Regexp::Expression::UnicodeProperty::Mark::Base; end
class Regexp::Expression::UnicodeProperty::Mark::Enclosing < ::Regexp::Expression::UnicodeProperty::Mark::Base; end
class Regexp::Expression::UnicodeProperty::Mark::Nonspacing < ::Regexp::Expression::UnicodeProperty::Mark::Base; end
class Regexp::Expression::UnicodeProperty::Mark::Spacing < ::Regexp::Expression::UnicodeProperty::Mark::Base; end
class Regexp::Expression::UnicodeProperty::Newline < ::Regexp::Expression::UnicodeProperty::Base; end
module Regexp::Expression::UnicodeProperty::Number; end
class Regexp::Expression::UnicodeProperty::Number::Any < ::Regexp::Expression::UnicodeProperty::Number::Base; end
class Regexp::Expression::UnicodeProperty::Number::Base < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Number::Decimal < ::Regexp::Expression::UnicodeProperty::Number::Base; end
class Regexp::Expression::UnicodeProperty::Number::Letter < ::Regexp::Expression::UnicodeProperty::Number::Base; end
class Regexp::Expression::UnicodeProperty::Number::Other < ::Regexp::Expression::UnicodeProperty::Number::Base; end
class Regexp::Expression::UnicodeProperty::Print < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Punct < ::Regexp::Expression::UnicodeProperty::Base; end
module Regexp::Expression::UnicodeProperty::Punctuation; end
class Regexp::Expression::UnicodeProperty::Punctuation::Any < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end
class Regexp::Expression::UnicodeProperty::Punctuation::Base < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Punctuation::Close < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end
class Regexp::Expression::UnicodeProperty::Punctuation::Connector < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end
class Regexp::Expression::UnicodeProperty::Punctuation::Dash < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end
class Regexp::Expression::UnicodeProperty::Punctuation::Final < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end
class Regexp::Expression::UnicodeProperty::Punctuation::Initial < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end
class Regexp::Expression::UnicodeProperty::Punctuation::Open < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end
class Regexp::Expression::UnicodeProperty::Punctuation::Other < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end
class Regexp::Expression::UnicodeProperty::Script < ::Regexp::Expression::UnicodeProperty::Base; end
module Regexp::Expression::UnicodeProperty::Separator; end
class Regexp::Expression::UnicodeProperty::Separator::Any < ::Regexp::Expression::UnicodeProperty::Separator::Base; end
class Regexp::Expression::UnicodeProperty::Separator::Base < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Separator::Line < ::Regexp::Expression::UnicodeProperty::Separator::Base; end
class Regexp::Expression::UnicodeProperty::Separator::Paragraph < ::Regexp::Expression::UnicodeProperty::Separator::Base; end
class Regexp::Expression::UnicodeProperty::Separator::Space < ::Regexp::Expression::UnicodeProperty::Separator::Base; end
class Regexp::Expression::UnicodeProperty::Space < ::Regexp::Expression::UnicodeProperty::Base; end
module Regexp::Expression::UnicodeProperty::Symbol; end
class Regexp::Expression::UnicodeProperty::Symbol::Any < ::Regexp::Expression::UnicodeProperty::Symbol::Base; end
class Regexp::Expression::UnicodeProperty::Symbol::Base < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Symbol::Currency < ::Regexp::Expression::UnicodeProperty::Symbol::Base; end
class Regexp::Expression::UnicodeProperty::Symbol::Math < ::Regexp::Expression::UnicodeProperty::Symbol::Base; end
class Regexp::Expression::UnicodeProperty::Symbol::Modifier < ::Regexp::Expression::UnicodeProperty::Symbol::Base; end
class Regexp::Expression::UnicodeProperty::Symbol::Other < ::Regexp::Expression::UnicodeProperty::Symbol::Base; end
class Regexp::Expression::UnicodeProperty::Upper < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Word < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::XPosixPunct < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Xdigit < ::Regexp::Expression::UnicodeProperty::Base; end

class Regexp::Expression::WhiteSpace < ::Regexp::Expression::FreeSpace
  # source://regexp_parser//lib/regexp_parser/expression/classes/free_space.rb#11
  def merge(exp); end
end

# A very thin wrapper around the scanner that breaks quantified literal runs,
# collects emitted tokens into an array, calculates their nesting depth, and
# normalizes tokens for the parser, and checks if they are implemented by the
# given syntax flavor.
class Regexp::Lexer
  # source://regexp_parser//lib/regexp_parser/lexer.rb#20
  def lex(input, syntax = T.unsafe(nil), options: T.unsafe(nil), &block); end

  private

  # source://regexp_parser//lib/regexp_parser/lexer.rb#71
  def ascend(type, token); end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#108
  def break_codepoint_list(token); end

  # called by scan to break a literal run that is longer than one character
  # into two separate tokens when it is followed by a quantifier
  #
  # source://regexp_parser//lib/regexp_parser/lexer.rb#95
  def break_literal(token); end

  # Returns the value of attribute conditional_nesting.
  #
  # source://regexp_parser//lib/regexp_parser/lexer.rb#69
  def conditional_nesting; end

  # Sets the attribute conditional_nesting
  #
  # @param value the value to set the attribute conditional_nesting to.
  #
  # source://regexp_parser//lib/regexp_parser/lexer.rb#69
  def conditional_nesting=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#82
  def descend(type, token); end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#123
  def merge_condition(current); end

  # Returns the value of attribute nesting.
  #
  # source://regexp_parser//lib/regexp_parser/lexer.rb#69
  def nesting; end

  # Sets the attribute nesting
  #
  # @param value the value to set the attribute nesting to.
  #
  # source://regexp_parser//lib/regexp_parser/lexer.rb#69
  def nesting=(_arg0); end

  # Returns the value of attribute set_nesting.
  #
  # source://regexp_parser//lib/regexp_parser/lexer.rb#69
  def set_nesting; end

  # Sets the attribute set_nesting
  #
  # @param value the value to set the attribute set_nesting to.
  #
  # source://regexp_parser//lib/regexp_parser/lexer.rb#69
  def set_nesting=(_arg0); end

  # Returns the value of attribute shift.
  #
  # source://regexp_parser//lib/regexp_parser/lexer.rb#69
  def shift; end

  # Sets the attribute shift
  #
  # @param value the value to set the attribute shift to.
  #
  # source://regexp_parser//lib/regexp_parser/lexer.rb#69
  def shift=(_arg0); end

  # Returns the value of attribute tokens.
  #
  # source://regexp_parser//lib/regexp_parser/lexer.rb#69
  def tokens; end

  # Sets the attribute tokens
  #
  # @param value the value to set the attribute tokens to.
  #
  # source://regexp_parser//lib/regexp_parser/lexer.rb#69
  def tokens=(_arg0); end

  class << self
    # source://regexp_parser//lib/regexp_parser/lexer.rb#16
    def lex(input, syntax = T.unsafe(nil), options: T.unsafe(nil), &block); end

    # source://regexp_parser//lib/regexp_parser/lexer.rb#16
    def scan(input, syntax = T.unsafe(nil), options: T.unsafe(nil), &block); end
  end
end

# source://regexp_parser//lib/regexp_parser/lexer.rb#12
Regexp::Lexer::CLOSING_TOKENS = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/lexer.rb#14
Regexp::Lexer::CONDITION_TOKENS = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/lexer.rb#7
Regexp::Lexer::OPENING_TOKENS = T.let(T.unsafe(nil), Array)

class Regexp::MatchLength
  include ::Enumerable

  # @return [MatchLength] a new instance of MatchLength
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#9
  def initialize(exp, opts = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#24
  def each(opts = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#35
  def endless_each; end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#44
  def fixed?; end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#40
  def include?(length); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#60
  def inspect; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#52
  def max; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#48
  def min; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#56
  def minmax; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#65
  def to_re; end

  private

  # Returns the value of attribute base_max.
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#71
  def base_max; end

  # Sets the attribute base_max
  #
  # @param value the value to set the attribute base_max to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#71
  def base_max=(_arg0); end

  # Returns the value of attribute base_min.
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#71
  def base_min; end

  # Sets the attribute base_min
  #
  # @param value the value to set the attribute base_min to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#71
  def base_min=(_arg0); end

  # Returns the value of attribute exp_class.
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#71
  def exp_class; end

  # Sets the attribute exp_class
  #
  # @param value the value to set the attribute exp_class to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#71
  def exp_class=(_arg0); end

  # Returns the value of attribute max_rep.
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#71
  def max_rep; end

  # Sets the attribute max_rep
  #
  # @param value the value to set the attribute max_rep to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#71
  def max_rep=(_arg0); end

  # Returns the value of attribute min_rep.
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#71
  def min_rep; end

  # Sets the attribute min_rep
  #
  # @param value the value to set the attribute min_rep to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#71
  def min_rep=(_arg0); end

  # Returns the value of attribute reify.
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#71
  def reify; end

  # Sets the attribute reify
  #
  # @param value the value to set the attribute reify to.
  #
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#71
  def reify=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#73
  def test_regexp; end

  class << self
    # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#4
    def of(obj); end
  end
end

class Regexp::Parser
  include ::Regexp::Expression
  include ::Regexp::Expression::UnicodeProperty

  # source://regexp_parser//lib/regexp_parser/parser.rb#25
  def parse(input, syntax = T.unsafe(nil), options: T.unsafe(nil), &block); end

  private

  # source://regexp_parser//lib/regexp_parser/parser.rb#615
  def active_opts; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#96
  def anchor(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#251
  def assign_effective_number(exp); end

  # Assigns referenced expressions to refering expressions, e.g. if there is
  # an instance of Backreference::Number, its #referenced_expression is set to
  # the instance of Group::Capture that it refers to via its number.
  #
  # source://regexp_parser//lib/regexp_parser/parser.rb#622
  def assign_referenced_expressions; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#224
  def backref(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#199
  def captured_group_count_at_level; end

  # Returns the value of attribute captured_group_counts.
  #
  # source://regexp_parser//lib/regexp_parser/parser.rb#53
  def captured_group_counts; end

  # Sets the attribute captured_group_counts
  #
  # @param value the value to set the attribute captured_group_counts to.
  #
  # source://regexp_parser//lib/regexp_parser/parser.rb#53
  def captured_group_counts=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#611
  def close_completed_character_set_range; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#207
  def close_group; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#579
  def close_set; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#256
  def conditional(token); end

  # Returns the value of attribute conditional_nesting.
  #
  # source://regexp_parser//lib/regexp_parser/parser.rb#53
  def conditional_nesting; end

  # Sets the attribute conditional_nesting
  #
  # @param value the value to set the attribute conditional_nesting to.
  #
  # source://regexp_parser//lib/regexp_parser/parser.rb#53
  def conditional_nesting=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#203
  def count_captured_group; end

  # @yield [node]
  #
  # source://regexp_parser//lib/regexp_parser/parser.rb#213
  def decrease_nesting; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#300
  def escape(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#57
  def extract_options(input, options); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#342
  def free_space(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#111
  def group(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#531
  def increase_level(exp); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#590
  def intersection(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#536
  def interval(target_node, token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#357
  def keep(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#361
  def literal(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#365
  def meta(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#575
  def negate_set; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#286
  def nest(exp); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#281
  def nest_conditional(exp); end

  # Returns the value of attribute nesting.
  #
  # source://regexp_parser//lib/regexp_parser/parser.rb#53
  def nesting; end

  # Sets the attribute nesting
  #
  # @param value the value to set the attribute nesting to.
  #
  # source://regexp_parser//lib/regexp_parser/parser.rb#53
  def nesting=(_arg0); end

  # Returns the value of attribute node.
  #
  # source://regexp_parser//lib/regexp_parser/parser.rb#53
  def node; end

  # Sets the attribute node
  #
  # @param value the value to set the attribute node to.
  #
  # source://regexp_parser//lib/regexp_parser/parser.rb#53
  def node=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#162
  def open_group(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#570
  def open_set(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#127
  def options_group(token); end

  # Returns the value of attribute options_stack.
  #
  # source://regexp_parser//lib/regexp_parser/parser.rb#53
  def options_stack; end

  # Sets the attribute options_stack
  #
  # @param value the value to set the attribute options_stack to.
  #
  # source://regexp_parser//lib/regexp_parser/parser.rb#53
  def options_stack=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#73
  def parse_token(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#387
  def posixclass(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#394
  def property(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#475
  def quantifier(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#583
  def range(token); end

  # Returns the value of attribute root.
  #
  # source://regexp_parser//lib/regexp_parser/parser.rb#53
  def root; end

  # Sets the attribute root
  #
  # @param value the value to set the attribute root to.
  #
  # source://regexp_parser//lib/regexp_parser/parser.rb#53
  def root=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#376
  def sequence_operation(klass, token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#558
  def set(token); end

  # Returns the value of attribute switching_options.
  #
  # source://regexp_parser//lib/regexp_parser/parser.rb#53
  def switching_options; end

  # Sets the attribute switching_options
  #
  # @param value the value to set the attribute switching_options to.
  #
  # source://regexp_parser//lib/regexp_parser/parser.rb#53
  def switching_options=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#195
  def total_captured_group_count; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#594
  def type(token); end

  # subtrees are transplanted to build Alternations, Intersections, Ranges
  #
  # source://regexp_parser//lib/regexp_parser/parser.rb#294
  def update_transplanted_subtree(exp, new_parent); end

  class << self
    # source://regexp_parser//lib/regexp_parser/parser.rb#21
    def parse(input, syntax = T.unsafe(nil), options: T.unsafe(nil), &block); end
  end
end

# source://regexp_parser//lib/regexp_parser/parser.rb#125
Regexp::Parser::ENC_FLAGS = T.let(T.unsafe(nil), Array)

# base class for all gem-specific errors (inherited but never raised itself)
class Regexp::Parser::Error < ::StandardError; end

# source://regexp_parser//lib/regexp_parser/parser.rb#124
Regexp::Parser::MOD_FLAGS = T.let(T.unsafe(nil), Array)

class Regexp::Parser::ParserError < ::Regexp::Parser::Error; end

# source://regexp_parser//lib/regexp_parser/parser.rb#392
Regexp::Parser::UPTokens = Regexp::Syntax::Token::UnicodeProperty

class Regexp::Parser::UnknownTokenError < ::Regexp::Parser::ParserError
  # @return [UnknownTokenError] a new instance of UnknownTokenError
  #
  # source://regexp_parser//lib/regexp_parser/parser.rb#16
  def initialize(type, token); end
end

class Regexp::Parser::UnknownTokenTypeError < ::Regexp::Parser::ParserError
  # @return [UnknownTokenTypeError] a new instance of UnknownTokenTypeError
  #
  # source://regexp_parser//lib/regexp_parser/parser.rb#10
  def initialize(type, token); end
end

# source://regexp_parser//lib/regexp_parser/version.rb#3
Regexp::Parser::VERSION = T.let(T.unsafe(nil), String)

class Regexp::Scanner
  # Emits an array with the details of the scanned pattern
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2620
  def emit(type, token, text); end

  # @raise [PrematureEndError]
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#76
  def scan(input_object, options: T.unsafe(nil), &block); end

  private

  # Appends one or more characters to the literal buffer, to be emitted later
  # by a call to emit_literal.
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2671
  def append_literal(data, ts, te); end

  # Returns the value of attribute block.
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2641
  def block; end

  # Sets the attribute block
  #
  # @param value the value to set the attribute block to.
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2641
  def block=(_arg0); end

  # Returns the value of attribute char_pos.
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2641
  def char_pos; end

  # Sets the attribute char_pos
  #
  # @param value the value to set the attribute char_pos to.
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2641
  def char_pos=(_arg0); end

  # Returns the value of attribute conditional_stack.
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2641
  def conditional_stack; end

  # Sets the attribute conditional_stack
  #
  # @param value the value to set the attribute conditional_stack to.
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2641
  def conditional_stack=(_arg0); end

  # Copy from ts to te from data as text
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2665
  def copy(data, ts, te); end

  # Emits the literal run collected by calls to the append_literal method.
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2677
  def emit_literal; end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2712
  def emit_meta_control_sequence(data, ts, te, token); end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2683
  def emit_options(text); end

  # Returns the value of attribute free_spacing.
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2641
  def free_spacing; end

  # Sets the attribute free_spacing
  #
  # @param value the value to set the attribute free_spacing to.
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2641
  def free_spacing=(_arg0); end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2644
  def free_spacing?(input_object, options); end

  # Returns the value of attribute group_depth.
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2641
  def group_depth; end

  # Sets the attribute group_depth
  #
  # @param value the value to set the attribute group_depth to.
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2641
  def group_depth=(_arg0); end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2656
  def in_group?; end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2660
  def in_set?; end

  # Returns the value of attribute literal.
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2641
  def literal; end

  # Sets the attribute literal
  #
  # @param value the value to set the attribute literal to.
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2641
  def literal=(_arg0); end

  # Returns the value of attribute set_depth.
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2641
  def set_depth; end

  # Sets the attribute set_depth
  #
  # @param value the value to set the attribute set_depth to.
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2641
  def set_depth=(_arg0); end

  # Returns the value of attribute spacing_stack.
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2641
  def spacing_stack; end

  # Sets the attribute spacing_stack
  #
  # @param value the value to set the attribute spacing_stack to.
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2641
  def spacing_stack=(_arg0); end

  # Returns the value of attribute tokens.
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2641
  def tokens; end

  # Sets the attribute tokens
  #
  # @param value the value to set the attribute tokens to.
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2641
  def tokens=(_arg0); end

  # Centralizes and unifies the handling of validation related
  # errors.
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2721
  def validation_error(type, what, reason); end

  class << self
    # source://regexp_parser//lib/regexp_parser/scanner.rb#2611
    def long_prop_map; end

    # source://regexp_parser//lib/regexp_parser/scanner.rb#2615
    def parse_prop_map(name); end

    # Scans the given regular expression text, or Regexp object and collects the
    # emitted token into an array that gets returned at the end. If a block is
    # given, it gets called for each emitted token.
    #
    # This method may raise errors if a syntax error is encountered.
    # --------------------------------------------------------------------------
    #
    # source://regexp_parser//lib/regexp_parser/scanner.rb#72
    def scan(input_object, options: T.unsafe(nil), &block); end

    # lazy-load property maps when first needed
    #
    # source://regexp_parser//lib/regexp_parser/scanner.rb#2607
    def short_prop_map; end
  end
end

# Invalid back reference. Used for name a number refs/calls.
class Regexp::Scanner::InvalidBackrefError < ::Regexp::Scanner::ValidationError
  # @return [InvalidBackrefError] a new instance of InvalidBackrefError
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#54
  def initialize(what, reason); end
end

# Invalid group. Used for named groups.
class Regexp::Scanner::InvalidGroupError < ::Regexp::Scanner::ValidationError
  # @return [InvalidGroupError] a new instance of InvalidGroupError
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#40
  def initialize(what, reason); end
end

# Invalid groupOption. Used for inline options.
class Regexp::Scanner::InvalidGroupOption < ::Regexp::Scanner::ValidationError
  # @return [InvalidGroupOption] a new instance of InvalidGroupOption
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#47
  def initialize(option, text); end
end

# Invalid sequence format. Used for escape sequences, mainly.
class Regexp::Scanner::InvalidSequenceError < ::Regexp::Scanner::ValidationError
  # @return [InvalidSequenceError] a new instance of InvalidSequenceError
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#33
  def initialize(what = T.unsafe(nil), where = T.unsafe(nil)); end
end

# Unexpected end of pattern
class Regexp::Scanner::PrematureEndError < ::Regexp::Scanner::ScannerError
  # @return [PrematureEndError] a new instance of PrematureEndError
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#26
  def initialize(where = T.unsafe(nil)); end
end

# General scanner error (catch all)
class Regexp::Scanner::ScannerError < ::Regexp::Parser::Error; end

# The property name was not recognized by the scanner.
class Regexp::Scanner::UnknownUnicodePropertyError < ::Regexp::Scanner::ValidationError
  # @return [UnknownUnicodePropertyError] a new instance of UnknownUnicodePropertyError
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#61
  def initialize(name); end
end

# Base for all scanner validation errors
class Regexp::Scanner::ValidationError < ::Regexp::Parser::Error
  # @return [ValidationError] a new instance of ValidationError
  #
  # source://regexp_parser//lib/regexp_parser/scanner.rb#19
  def initialize(reason); end
end

# After loading all the tokens the map is full. Extract all tokens and types
# into the All and Types constants.
module Regexp::Syntax
  private

  # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#71
  def comparable_version(name); end

  # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#43
  def const_missing(const_name); end

  # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#50
  def fallback_version_class(version); end

  # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#59
  def inherit_from_version(parent_version, new_version); end

  # Loads and instantiates an instance of the syntax specification class for
  # the given syntax version name. The special names 'any' and '*' return an
  # instance of Syntax::Any.
  #
  # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#23
  def new(name); end

  # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#67
  def specified_versions; end

  # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#28
  def supported?(name); end

  # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#33
  def version_class(version); end

  # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#39
  def version_const_name(version_string); end

  # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#76
  def warn_if_future_version(const_name); end

  class << self
    # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#71
    def comparable_version(name); end

    # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#43
    def const_missing(const_name); end

    # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#50
    def fallback_version_class(version); end

    # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#59
    def inherit_from_version(parent_version, new_version); end

    # Loads and instantiates an instance of the syntax specification class for
    # the given syntax version name. The special names 'any' and '*' return an
    # instance of Syntax::Any.
    #
    # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#23
    def new(name); end

    # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#67
    def specified_versions; end

    # @return [Boolean]
    #
    # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#28
    def supported?(name); end

    # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#33
    def version_class(version); end

    # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#39
    def version_const_name(version_string); end

    # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#76
    def warn_if_future_version(const_name); end
  end
end

# A syntax that always returns true, passing all tokens as implemented. This
# is useful during development, testing, and should be useful for some types
# of transformations as well.
class Regexp::Syntax::Any < ::Regexp::Syntax::Base
  # @return [Any] a new instance of Any
  #
  # source://regexp_parser//lib/regexp_parser/syntax/any.rb#6
  def initialize; end

  # source://regexp_parser//lib/regexp_parser/syntax/any.rb#11
  def implements!(_type, _token); end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/syntax/any.rb#10
  def implements?(_type, _token); end
end

# A lookup map of supported types and tokens in a given syntax
class Regexp::Syntax::Base
  include ::Regexp::Syntax::Token

  # @return [Base] a new instance of Base
  #
  # source://regexp_parser//lib/regexp_parser/syntax/base.rb#12
  def initialize; end

  # @raise [NotImplementedError]
  #
  # source://regexp_parser//lib/regexp_parser/syntax/base.rb#40
  def check!(type, token); end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/syntax/base.rb#35
  def check?(type, token); end

  # source://regexp_parser//lib/regexp_parser/syntax/base.rb#31
  def excludes(type, tokens); end

  # source://regexp_parser//lib/regexp_parser/syntax/base.rb#19
  def features; end

  # source://regexp_parser//lib/regexp_parser/syntax/base.rb#23
  def implementations(type); end

  # source://regexp_parser//lib/regexp_parser/syntax/base.rb#27
  def implements(type, tokens); end

  # @raise [NotImplementedError]
  #
  # source://regexp_parser//lib/regexp_parser/syntax/base.rb#40
  def implements!(type, token); end

  # @return [Boolean]
  #
  # source://regexp_parser//lib/regexp_parser/syntax/base.rb#35
  def implements?(type, token); end

  # source://regexp_parser//lib/regexp_parser/syntax/base.rb#46
  def normalize(type, token); end

  # source://regexp_parser//lib/regexp_parser/syntax/base.rb#66
  def normalize_backref(type, token); end

  # source://regexp_parser//lib/regexp_parser/syntax/base.rb#57
  def normalize_group(type, token); end

  class << self
    # source://regexp_parser//lib/regexp_parser/syntax/base.rb#89
    def inspect; end
  end
end

class Regexp::Syntax::InvalidVersionNameError < ::Regexp::Syntax::SyntaxError
  # @return [InvalidVersionNameError] a new instance of InvalidVersionNameError
  #
  # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#7
  def initialize(name); end
end

class Regexp::Syntax::NotImplementedError < ::Regexp::Syntax::SyntaxError
  # @return [NotImplementedError] a new instance of NotImplementedError
  #
  # source://regexp_parser//lib/regexp_parser/syntax/base.rb#3
  def initialize(syntax, type, token); end
end

class Regexp::Syntax::SyntaxError < ::Regexp::Parser::Error; end
module Regexp::Syntax::Token; end

# source://regexp_parser//lib/regexp_parser/syntax/token.rb#42
Regexp::Syntax::Token::All = T.let(T.unsafe(nil), Array)

module Regexp::Syntax::Token::Anchor; end

# source://regexp_parser//lib/regexp_parser/syntax/token/anchor.rb#9
Regexp::Syntax::Token::Anchor::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/anchor.rb#4
Regexp::Syntax::Token::Anchor::Basic = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/anchor.rb#5
Regexp::Syntax::Token::Anchor::Extended = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/anchor.rb#7
Regexp::Syntax::Token::Anchor::MatchStart = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/anchor.rb#6
Regexp::Syntax::Token::Anchor::String = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/anchor.rb#10
Regexp::Syntax::Token::Anchor::Type = T.let(T.unsafe(nil), Symbol)

module Regexp::Syntax::Token::Assertion; end

# source://regexp_parser//lib/regexp_parser/syntax/token/assertion.rb#7
Regexp::Syntax::Token::Assertion::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/assertion.rb#4
Regexp::Syntax::Token::Assertion::Lookahead = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/assertion.rb#5
Regexp::Syntax::Token::Assertion::Lookbehind = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/assertion.rb#8
Regexp::Syntax::Token::Assertion::Type = T.let(T.unsafe(nil), Symbol)

module Regexp::Syntax::Token::Backreference; end

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#15
Regexp::Syntax::Token::Backreference::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#7
Regexp::Syntax::Token::Backreference::Name = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#6
Regexp::Syntax::Token::Backreference::Number = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#5
Regexp::Syntax::Token::Backreference::NumberRef = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#4
Regexp::Syntax::Token::Backreference::Plain = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#9
Regexp::Syntax::Token::Backreference::RecursionLevel = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#16
Regexp::Syntax::Token::Backreference::Type = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#11
Regexp::Syntax::Token::Backreference::V1_8_6 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#13
Regexp::Syntax::Token::Backreference::V1_9_1 = T.let(T.unsafe(nil), Array)

module Regexp::Syntax::Token::CharacterSet; end

# source://regexp_parser//lib/regexp_parser/syntax/token/character_set.rb#7
Regexp::Syntax::Token::CharacterSet::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/character_set.rb#4
Regexp::Syntax::Token::CharacterSet::Basic = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/character_set.rb#5
Regexp::Syntax::Token::CharacterSet::Extended = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/character_set.rb#8
Regexp::Syntax::Token::CharacterSet::Type = T.let(T.unsafe(nil), Symbol)

module Regexp::Syntax::Token::CharacterType; end

# source://regexp_parser//lib/regexp_parser/syntax/token/character_type.rb#10
Regexp::Syntax::Token::CharacterType::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/character_type.rb#4
Regexp::Syntax::Token::CharacterType::Basic = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/character_type.rb#8
Regexp::Syntax::Token::CharacterType::Clustered = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/character_type.rb#5
Regexp::Syntax::Token::CharacterType::Extended = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/character_type.rb#6
Regexp::Syntax::Token::CharacterType::Hex = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/character_type.rb#11
Regexp::Syntax::Token::CharacterType::Type = T.let(T.unsafe(nil), Symbol)

module Regexp::Syntax::Token::Conditional; end

# source://regexp_parser//lib/regexp_parser/syntax/token/conditional.rb#9
Regexp::Syntax::Token::Conditional::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/conditional.rb#6
Regexp::Syntax::Token::Conditional::Condition = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/conditional.rb#4
Regexp::Syntax::Token::Conditional::Delimiters = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/conditional.rb#7
Regexp::Syntax::Token::Conditional::Separator = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/conditional.rb#11
Regexp::Syntax::Token::Conditional::Type = T.let(T.unsafe(nil), Symbol)

# TODO: unify naming with RE::EscapeSequence, on way or the other, in v3.0.0
module Regexp::Syntax::Token::Escape; end

# source://regexp_parser//lib/regexp_parser/syntax/token/escape.rb#9
Regexp::Syntax::Token::Escape::ASCII = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/escape.rb#25
Regexp::Syntax::Token::Escape::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/escape.rb#5
Regexp::Syntax::Token::Escape::Basic = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/escape.rb#7
Regexp::Syntax::Token::Escape::Control = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/escape.rb#21
Regexp::Syntax::Token::Escape::Hex = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/escape.rb#14
Regexp::Syntax::Token::Escape::Meta = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/escape.rb#23
Regexp::Syntax::Token::Escape::Octal = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/escape.rb#26
Regexp::Syntax::Token::Escape::Type = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token/escape.rb#12
Regexp::Syntax::Token::Escape::Unicode = T.let(T.unsafe(nil), Array)

module Regexp::Syntax::Token::FreeSpace; end

# source://regexp_parser//lib/regexp_parser/syntax/token.rb#12
Regexp::Syntax::Token::FreeSpace::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token.rb#13
Regexp::Syntax::Token::FreeSpace::Type = T.let(T.unsafe(nil), Symbol)

module Regexp::Syntax::Token::Group; end

# source://regexp_parser//lib/regexp_parser/syntax/token/group.rb#17
Regexp::Syntax::Token::Group::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/group.rb#8
Regexp::Syntax::Token::Group::Atomic = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/group.rb#4
Regexp::Syntax::Token::Group::Basic = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/group.rb#10
Regexp::Syntax::Token::Group::Comment = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/group.rb#5
Regexp::Syntax::Token::Group::Extended = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/group.rb#7
Regexp::Syntax::Token::Group::Named = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/group.rb#9
Regexp::Syntax::Token::Group::Passive = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/group.rb#18
Regexp::Syntax::Token::Group::Type = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token/group.rb#12
Regexp::Syntax::Token::Group::V1_8_6 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/group.rb#15
Regexp::Syntax::Token::Group::V2_4_1 = T.let(T.unsafe(nil), Array)

module Regexp::Syntax::Token::Keep; end

# source://regexp_parser//lib/regexp_parser/syntax/token/keep.rb#6
Regexp::Syntax::Token::Keep::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/keep.rb#4
Regexp::Syntax::Token::Keep::Mark = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/keep.rb#7
Regexp::Syntax::Token::Keep::Type = T.let(T.unsafe(nil), Symbol)

module Regexp::Syntax::Token::Literal; end

# source://regexp_parser//lib/regexp_parser/syntax/token.rb#7
Regexp::Syntax::Token::Literal::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token.rb#8
Regexp::Syntax::Token::Literal::Type = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token.rb#4
Regexp::Syntax::Token::Map = T.let(T.unsafe(nil), Hash)

module Regexp::Syntax::Token::Meta; end

# source://regexp_parser//lib/regexp_parser/syntax/token/meta.rb#7
Regexp::Syntax::Token::Meta::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/meta.rb#4
Regexp::Syntax::Token::Meta::Basic = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/meta.rb#5
Regexp::Syntax::Token::Meta::Extended = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/meta.rb#8
Regexp::Syntax::Token::Meta::Type = T.let(T.unsafe(nil), Symbol)

module Regexp::Syntax::Token::PosixClass; end

# source://regexp_parser//lib/regexp_parser/syntax/token/posix_class.rb#9
Regexp::Syntax::Token::PosixClass::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/posix_class.rb#7
Regexp::Syntax::Token::PosixClass::Extensions = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/posix_class.rb#11
Regexp::Syntax::Token::PosixClass::NonType = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token/posix_class.rb#4
Regexp::Syntax::Token::PosixClass::Standard = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/posix_class.rb#10
Regexp::Syntax::Token::PosixClass::Type = T.let(T.unsafe(nil), Symbol)

module Regexp::Syntax::Token::Quantifier; end

# source://regexp_parser//lib/regexp_parser/syntax/token/quantifier.rb#29
Regexp::Syntax::Token::Quantifier::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/quantifier.rb#4
Regexp::Syntax::Token::Quantifier::Greedy = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/quantifier.rb#22
Regexp::Syntax::Token::Quantifier::Interval = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/quantifier.rb#26
Regexp::Syntax::Token::Quantifier::IntervalAll = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/quantifier.rb#24
Regexp::Syntax::Token::Quantifier::IntervalPossessive = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/quantifier.rb#23
Regexp::Syntax::Token::Quantifier::IntervalReluctant = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/quantifier.rb#16
Regexp::Syntax::Token::Quantifier::Possessive = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/quantifier.rb#10
Regexp::Syntax::Token::Quantifier::Reluctant = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/quantifier.rb#30
Regexp::Syntax::Token::Quantifier::Type = T.let(T.unsafe(nil), Symbol)

# Type is the same as Backreference so keeping it here, for now.
module Regexp::Syntax::Token::SubexpressionCall; end

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#24
Regexp::Syntax::Token::SubexpressionCall::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#21
Regexp::Syntax::Token::SubexpressionCall::Name = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#22
Regexp::Syntax::Token::SubexpressionCall::Number = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token.rb#43
Regexp::Syntax::Token::Types = T.let(T.unsafe(nil), Array)

module Regexp::Syntax::Token::UnicodeProperty; end

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#62
Regexp::Syntax::Token::UnicodeProperty::Age = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#40
Regexp::Syntax::Token::UnicodeProperty::Age_V1_9_3 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#44
Regexp::Syntax::Token::UnicodeProperty::Age_V2_0_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#46
Regexp::Syntax::Token::UnicodeProperty::Age_V2_2_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#48
Regexp::Syntax::Token::UnicodeProperty::Age_V2_3_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#50
Regexp::Syntax::Token::UnicodeProperty::Age_V2_4_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#52
Regexp::Syntax::Token::UnicodeProperty::Age_V2_5_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#54
Regexp::Syntax::Token::UnicodeProperty::Age_V2_6_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#56
Regexp::Syntax::Token::UnicodeProperty::Age_V2_6_2 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#58
Regexp::Syntax::Token::UnicodeProperty::Age_V2_6_3 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#60
Regexp::Syntax::Token::UnicodeProperty::Age_V3_1_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#687
Regexp::Syntax::Token::UnicodeProperty::All = T.let(T.unsafe(nil), Array)

module Regexp::Syntax::Token::UnicodeProperty::Category; end

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#36
Regexp::Syntax::Token::UnicodeProperty::Category::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#33
Regexp::Syntax::Token::UnicodeProperty::Category::Codepoint = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#14
Regexp::Syntax::Token::UnicodeProperty::Category::Letter = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#17
Regexp::Syntax::Token::UnicodeProperty::Category::Mark = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#20
Regexp::Syntax::Token::UnicodeProperty::Category::Number = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#23
Regexp::Syntax::Token::UnicodeProperty::Category::Punctuation = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#30
Regexp::Syntax::Token::UnicodeProperty::Category::Separator = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#27
Regexp::Syntax::Token::UnicodeProperty::Category::Symbol = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#6
Regexp::Syntax::Token::UnicodeProperty::CharType_V1_9_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#9
Regexp::Syntax::Token::UnicodeProperty::CharType_V2_5_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#131
Regexp::Syntax::Token::UnicodeProperty::Derived = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#64
Regexp::Syntax::Token::UnicodeProperty::Derived_V1_9_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#118
Regexp::Syntax::Token::UnicodeProperty::Derived_V2_0_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#123
Regexp::Syntax::Token::UnicodeProperty::Derived_V2_4_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#127
Regexp::Syntax::Token::UnicodeProperty::Derived_V2_5_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#673
Regexp::Syntax::Token::UnicodeProperty::Emoji = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#665
Regexp::Syntax::Token::UnicodeProperty::Emoji_V2_5_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#690
Regexp::Syntax::Token::UnicodeProperty::NonType = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#11
Regexp::Syntax::Token::UnicodeProperty::POSIX = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#325
Regexp::Syntax::Token::UnicodeProperty::Script = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#133
Regexp::Syntax::Token::UnicodeProperty::Script_V1_9_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#229
Regexp::Syntax::Token::UnicodeProperty::Script_V1_9_3 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#235
Regexp::Syntax::Token::UnicodeProperty::Script_V2_0_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#245
Regexp::Syntax::Token::UnicodeProperty::Script_V2_2_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#271
Regexp::Syntax::Token::UnicodeProperty::Script_V2_3_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#280
Regexp::Syntax::Token::UnicodeProperty::Script_V2_4_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#289
Regexp::Syntax::Token::UnicodeProperty::Script_V2_5_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#296
Regexp::Syntax::Token::UnicodeProperty::Script_V2_6_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#306
Regexp::Syntax::Token::UnicodeProperty::Script_V2_6_2 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#318
Regexp::Syntax::Token::UnicodeProperty::Script_V3_1_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#689
Regexp::Syntax::Token::UnicodeProperty::Type = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#663
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#327
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V1_9_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#426
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V2_0_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#554
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V2_2_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#589
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V2_3_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#602
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V2_4_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#616
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V2_5_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#626
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V2_6_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#640
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V2_6_2 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#652
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V3_1_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#675
Regexp::Syntax::Token::UnicodeProperty::V1_9_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#676
Regexp::Syntax::Token::UnicodeProperty::V1_9_3 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#677
Regexp::Syntax::Token::UnicodeProperty::V2_0_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#678
Regexp::Syntax::Token::UnicodeProperty::V2_2_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#679
Regexp::Syntax::Token::UnicodeProperty::V2_3_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#680
Regexp::Syntax::Token::UnicodeProperty::V2_4_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#681
Regexp::Syntax::Token::UnicodeProperty::V2_5_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#682
Regexp::Syntax::Token::UnicodeProperty::V2_6_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#683
Regexp::Syntax::Token::UnicodeProperty::V2_6_2 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#684
Regexp::Syntax::Token::UnicodeProperty::V2_6_3 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#685
Regexp::Syntax::Token::UnicodeProperty::V3_1_0 = T.let(T.unsafe(nil), Array)

class Regexp::Syntax::UnknownSyntaxNameError < ::Regexp::Syntax::SyntaxError
  # @return [UnknownSyntaxNameError] a new instance of UnknownSyntaxNameError
  #
  # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#13
  def initialize(name); end
end

class Regexp::Syntax::V1_8_6 < ::Regexp::Syntax::Base
  # @return [V1_8_6] a new instance of V1_8_6
  #
  # source://regexp_parser//lib/regexp_parser/syntax/versions/1.8.6.rb#3
  def initialize; end
end

class Regexp::Syntax::V1_9 < ::Regexp::Syntax::V1_9_3; end

class Regexp::Syntax::V1_9_1 < ::Regexp::Syntax::V1_8_6
  # @return [V1_9_1] a new instance of V1_9_1
  #
  # source://regexp_parser//lib/regexp_parser/syntax/versions/1.9.1.rb#3
  def initialize; end
end

class Regexp::Syntax::V1_9_3 < ::Regexp::Syntax::V1_9_1
  # @return [V1_9_3] a new instance of V1_9_3
  #
  # source://regexp_parser//lib/regexp_parser/syntax/versions/1.9.3.rb#3
  def initialize; end
end

# use the last 1.9 release as the base
class Regexp::Syntax::V2_0_0 < ::Regexp::Syntax::V1_9
  # @return [V2_0_0] a new instance of V2_0_0
  #
  # source://regexp_parser//lib/regexp_parser/syntax/versions/2.0.0.rb#4
  def initialize; end
end

class Regexp::Syntax::V2_1 < ::Regexp::Syntax::V2_0_0; end
class Regexp::Syntax::V2_2 < ::Regexp::Syntax::V2_2_0; end

class Regexp::Syntax::V2_2_0 < ::Regexp::Syntax::V2_1
  # @return [V2_2_0] a new instance of V2_2_0
  #
  # source://regexp_parser//lib/regexp_parser/syntax/versions/2.2.0.rb#3
  def initialize; end
end

class Regexp::Syntax::V2_3 < ::Regexp::Syntax::V2_3_0; end

class Regexp::Syntax::V2_3_0 < ::Regexp::Syntax::V2_2
  # @return [V2_3_0] a new instance of V2_3_0
  #
  # source://regexp_parser//lib/regexp_parser/syntax/versions/2.3.0.rb#3
  def initialize; end
end

class Regexp::Syntax::V2_4 < ::Regexp::Syntax::V2_4_1; end

class Regexp::Syntax::V2_4_0 < ::Regexp::Syntax::V2_3
  # @return [V2_4_0] a new instance of V2_4_0
  #
  # source://regexp_parser//lib/regexp_parser/syntax/versions/2.4.0.rb#3
  def initialize; end
end

class Regexp::Syntax::V2_4_1 < ::Regexp::Syntax::V2_4_0
  # @return [V2_4_1] a new instance of V2_4_1
  #
  # source://regexp_parser//lib/regexp_parser/syntax/versions/2.4.1.rb#3
  def initialize; end
end

class Regexp::Syntax::V2_5 < ::Regexp::Syntax::V2_5_0; end

class Regexp::Syntax::V2_5_0 < ::Regexp::Syntax::V2_4
  # @return [V2_5_0] a new instance of V2_5_0
  #
  # source://regexp_parser//lib/regexp_parser/syntax/versions/2.5.0.rb#3
  def initialize; end
end

class Regexp::Syntax::V2_6_0 < ::Regexp::Syntax::V2_5
  # @return [V2_6_0] a new instance of V2_6_0
  #
  # source://regexp_parser//lib/regexp_parser/syntax/versions/2.6.0.rb#3
  def initialize; end
end

class Regexp::Syntax::V2_6_2 < ::Regexp::Syntax::V2_6_0
  # @return [V2_6_2] a new instance of V2_6_2
  #
  # source://regexp_parser//lib/regexp_parser/syntax/versions/2.6.2.rb#3
  def initialize; end
end

class Regexp::Syntax::V2_6_3 < ::Regexp::Syntax::V2_6_2
  # @return [V2_6_3] a new instance of V2_6_3
  #
  # source://regexp_parser//lib/regexp_parser/syntax/versions/2.6.3.rb#3
  def initialize; end
end

class Regexp::Syntax::V3_1_0 < ::Regexp::Syntax::V2_6_3
  # @return [V3_1_0] a new instance of V3_1_0
  #
  # source://regexp_parser//lib/regexp_parser/syntax/versions/3.1.0.rb#3
  def initialize; end
end

# source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#4
Regexp::Syntax::VERSION_CONST_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#2
Regexp::Syntax::VERSION_FORMAT = T.let(T.unsafe(nil), String)

# source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#3
Regexp::Syntax::VERSION_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://regexp_parser//lib/regexp_parser/token.rb#2
Regexp::TOKEN_KEYS = T.let(T.unsafe(nil), Array)

class Regexp::Token < ::Struct
  def conditional_level; end
  def conditional_level=(_); end

  # source://regexp_parser//lib/regexp_parser/token.rb#20
  def length; end

  def level; end
  def level=(_); end

  # Returns the value of attribute next.
  #
  # source://regexp_parser//lib/regexp_parser/token.rb#14
  def next; end

  # Sets the attribute next
  #
  # @param value the value to set the attribute next to.
  #
  # source://regexp_parser//lib/regexp_parser/token.rb#14
  def next=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/token.rb#16
  def offset; end

  # Returns the value of attribute previous.
  #
  # source://regexp_parser//lib/regexp_parser/token.rb#14
  def previous; end

  # Sets the attribute previous
  #
  # @param value the value to set the attribute previous to.
  #
  # source://regexp_parser//lib/regexp_parser/token.rb#14
  def previous=(_arg0); end

  def set_level; end
  def set_level=(_); end
  def te; end
  def te=(_); end
  def text; end
  def text=(_); end
  def token; end
  def token=(_); end
  def ts; end
  def ts=(_); end
  def type; end
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end
